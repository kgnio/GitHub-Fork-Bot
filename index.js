require("dotenv").config();
const fs = require("fs");
const path = require("path");

const { searchRepos } = require("./src/github/searchRepos");
const { forkRepo } = require("./src/github/forkRepo");
const { cloneRepo } = require("./src/github/cloneRepo");
const { formatReadme } = require("./src/formatters/formatReadme");
const { runPrettier } = require("./src/formatters/runPrettier");
const { formatCode } = require("./src/formatters/formatCode");
const { pushChanges } = require("./src/github/pushChanges");
const { createPullRequest } = require("./src/github/createPullRequest");
const { addToLog } = require("./src/utils/forkLogger");
const { addJsDocComments } = require("./src/formatters/addJsDocComments");
const { createDockerfile } = require("./src/formatters/createDockerfile");
const {
  createDockerWorkflow,
} = require("./src/formatters/createDockerWorkflow");
const { checkAndAddLicense } = require("./src/formatters/formatLicence");
const { checkAndFixScaffolding } = require("./src/formatters/formatScaffold");
const { analyzeCodeQuality } = require("./src/ai/analyzeCodeQuality");
const {
  generateDynamicPRMessage,
} = require("./src/pr/generateDynamicPRMessage");
const { generateMissingTests } = require("./src/tests/generateMissingTests");

// ‚úÖ new modules
const { runOpenApiIntegrate } = require("./src/modules/openapiIntegrate");
const { runDeadCodeDetector } = require("./src/modules/deadCodeDetector");
const { ensureCI } = require("./src/modules/ensureCI");
const { optimize } = require("./src/modules/optimizePackageJson");
const { ensureCompose } = require("./src/modules/dockerComposeGen");

// ‚úÖ security
const { run: runSecurityPatcher } = require("./src/security/securityPatcher");

async function safeRemoveDir(dirPath) {
  return new Promise((resolve) => {
    setTimeout(() => {
      try {
        fs.rmSync(dirPath, { recursive: true, force: true });
        console.log(`üóëÔ∏è Cleanup: ${dirPath} deleted.`);
      } catch (err) {
        console.warn(`‚ö†Ô∏è Failed to delete forks folder: ${err.message}`);
      }
      resolve();
    }, 1500);
  });
}

async function main() {
  console.log("üöÄ Starting...");

  const changeLog = [];

  const repos = await searchRepos();
  if (!repos.length) {
    console.log("üö´ No suitable repository found to process.");
    return;
  }

  const repo = repos[0];
  const { full_name, default_branch, owner } = repo;

  const forkedRepo = await forkRepo(full_name);
  if (!forkedRepo) return;

  const localPath = await cloneRepo(forkedRepo.clone_url, forkedRepo.name);
  if (!localPath) return;

  formatReadme(localPath, repo, { dockerfileAdded: true, workflowAdded: true });
  changeLog.push("üìù README file was generated");

  createDockerfile(localPath);
  changeLog.push("üê≥ Dockerfile was added for containerization");

  createDockerWorkflow(localPath);
  changeLog.push("‚öôÔ∏è GitHub Actions workflow was added");

  await runPrettier(localPath);
  formatCode(localPath);
  changeLog.push("üé® Code was formatted with Prettier");

  const licenseAdded = await checkAndAddLicense(
    forkedRepo.owner.login,
    forkedRepo.name
  );
  if (licenseAdded) changeLog.push("üìÑ MIT LICENSE was added");

  const scaffoldAdded = await checkAndFixScaffolding(
    forkedRepo.owner.login,
    forkedRepo.name
  );
  if (scaffoldAdded) {
    changeLog.push(
      "üìÅ Project structure folders (src/, tests/, docs/) were created"
    );
  }

  await addJsDocComments(localPath);
  changeLog.push("üí¨ JSDoc comments were added");

  // ‚úÖ OpenAPI integration
  try {
    await runOpenApiIntegrate(localPath);
    changeLog.push(
      "üìò OpenAPI integrated (docs/openapi.json + /docs + README)"
    );
  } catch (err) {
    console.warn("‚ö†Ô∏è OpenAPI integration error:", err.message);
  }

  let aiQualityReport = null;

  // 1) AI code quality report
  const result = await analyzeCodeQuality(localPath);
  if (typeof result === "string" && result.trim().length > 0) {
    aiQualityReport = result;
    changeLog.push("üìä AI-powered code quality report generated");
  } else {
    console.log("‚ÑπÔ∏è No suitable changes found for code quality report.");
  }

  await generateMissingTests(localPath);
  changeLog.push("üß™ Missing test files were generated by AI");

  // ‚úÖ Dead code report
  try {
    await runDeadCodeDetector(localPath);
    changeLog.push("ü™ì Dead code report generated");
  } catch (err) {
    console.warn("‚ö†Ô∏è Dead code detector error:", err.message);
  }

  // ‚úÖ package.json optimize
  try {
    const optRes = optimize(localPath, { removeUnused: false });
    if (optRes.changed) changeLog.push("üßπ package.json optimized");
  } catch (err) {
    console.warn("‚ö†Ô∏è package.json optimize error:", err.message);
  }

  // ‚úÖ Security patcher (repo root)
  try {
    const prevCwd = process.cwd();
    process.chdir(localPath);
    await runSecurityPatcher(); // owner/repo/branch auto-detected
    process.chdir(prevCwd);
    changeLog.push("üîê Security patcher applied (deps/audit)");
  } catch (err) {
    console.warn("‚ö†Ô∏è Security patcher could not be executed:", err.message);
  }

  // ‚úÖ CI workflow (if missing, add)
  try {
    if (ensureCI(localPath))
      changeLog.push("ü§ñ CI added (.github/workflows/ci.yml)");
  } catch (err) {
    console.warn("‚ö†Ô∏è CI ensure error:", err.message);
  }

  // ‚úÖ docker-compose.yml (if missing, add)
  try {
    if (ensureCompose(localPath)) {
      changeLog.push(
        "üß© docker-compose.yml generated (app + optional mongo/redis)"
      );
    }
  } catch (err) {
    console.warn("‚ö†Ô∏è Docker compose generation error:", err.message);
  }

  // 2) Push + PR
  const committed = await pushChanges(localPath, default_branch);
  let prUrl = null;
  let status = "no-commit";

  if (committed) {
    const dynamicBody = generateDynamicPRMessage(localPath, {
      dockerfileAdded: true,
      workflowAdded: true,
      changeLog,
      aiQualityReport,
    });

    const pr = await createPullRequest({
      owner: owner.login,
      repo: forkedRepo.name,
      forkOwner: forkedRepo.owner.login,
      branch: default_branch,
      repoMeta: repo,
      commitWasPushed: true,
      dynamicBody,
    });

    if (pr?.alreadyExists) {
      console.log("‚ÑπÔ∏è PR was already open, this repository was skipped.");
      prUrl = pr.html_url;
      status = "already-pr-opened";
    } else if (pr) {
      console.log("‚úÖ New PR created.");
      prUrl = pr.html_url;
      status = "success";
    } else {
      console.log("‚ÑπÔ∏è PR was not created.");
      status = "no-pr";
    }
  }

  addToLog({
    full_name: repo.full_name,
    forked_as: forkedRepo.full_name,
    created_at: new Date().toISOString(),
    pr_url: prUrl,
    status,
  });

  if (path.resolve(process.cwd()) !== path.resolve(localPath)) {
    await safeRemoveDir(localPath);
  } else {
    console.warn(
      "‚ö†Ô∏è Deletion cancelled because working directory is inside the repo."
    );
  }

  console.log("‚úÖ Bot process completed.");
}

main();
